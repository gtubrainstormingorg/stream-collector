package com.snowplowanalytics.snowplow.collector.core

import scala.concurrent.duration._
import scala.collection.mutable.ListBuffer

import org.apache.commons.codec.binary.Base64
import org.apache.commons.codec.digest.DigestUtils

import java.nio.charset.StandardCharsets

import cats.implicits._

import cats.effect._
import cats.effect.unsafe.implicits.global
import cats.effect.testkit.TestControl

import org.http4s._
import org.http4s.client.{Client => HttpClient}

import io.circe._
import io.circe.parser._
import io.circe.syntax._

import fs2.Stream

import com.snowplowanalytics.snowplow.scalatracker.emitters.http4s.ceTracking

import org.specs2.mutable.Specification

class TelemetrySpec extends Specification {

  case class ProbeTelemetry(
    telemetryStream: Stream[IO, Unit],
    telemetryEvents: ListBuffer[Json],
    hostnameSet: Telemetry.HostnameSet[IO]
  )

  val appId    = "testAppId"
  val region   = Some("testRegion")
  val cloud    = Some("testCloud")
  val interval = 5.minutes
  val telemetryConfig = Config.Telemetry(
    disable         = false,
    interval        = interval,
    method          = "POST",
    url             = "127.0.0.1",
    port            = 443,
    secure          = true,
    userProvidedId  = None,
    moduleName      = None,
    moduleVersion   = None,
    instanceId      = None,
    autoGeneratedId = None
  )

  def probeTelemetry(telemetryConfig: Config.Telemetry): ProbeTelemetry = {
    val telemetryEvents = ListBuffer[Json]()
    val httpApp = HttpRoutes
      .of[IO] {
        case req =>
          IO {
            telemetryEvents += extractTelemetryEvent(req)
            Response[IO](status = Status.Ok)
          }
      }
      .orNotFound
    val client      = HttpClient.fromHttpApp[IO](httpApp)
    val hostnameSet = Telemetry.HostnameSet.init[IO](telemetryConfig).unsafeRunSync()
    val telemetryStream = Telemetry.run[IO](
      telemetryConfig,
      client,
      TestUtils.appInfo,
      appId,
      region,
      cloud,
      hostnameSet
    )
    ProbeTelemetry(telemetryStream, telemetryEvents, hostnameSet)
  }

  def extractTelemetryEvent(req: Request[IO]): Json = {
    val body        = req.bodyText.compile.string.unsafeRunSync()
    val jsonBody    = parse(body).toOption.get
    val uepxEncoded = jsonBody.hcursor.downField("data").downN(0).downField("ue_px").as[String].toOption.get
    val uePxDecoded = new String(Base64.decodeBase64(uepxEncoded), StandardCharsets.UTF_8)
    parse(uePxDecoded).toOption.get.hcursor.downField("data").as[Json].toOption.get
  }

  def expectedEvent(
    config: Config.Telemetry,
    hostnameCount: Int
  ): Json = {
    val hashedHostnames = (1 to hostnameCount).map(i => DigestUtils.sha256Hex(i.toString)).toSet
    Json.obj(
      "schema" -> "iglu:com.snowplowanalytics.oss/oss_context/jsonschema/1-0-2".asJson,
      "data" -> Json.obj(
        "userProvidedId"     -> config.userProvidedId.asJson,
        "autoGeneratedId"    -> config.autoGeneratedId.asJson,
        "moduleName"         -> config.moduleName.asJson,
        "moduleVersion"      -> config.moduleVersion.asJson,
        "instanceId"         -> config.instanceId.asJson,
        "appGeneratedId"     -> appId.asJson,
        "cloud"              -> cloud.asJson,
        "region"             -> region.asJson,
        "applicationName"    -> TestUtils.appInfo.name.asJson,
        "applicationVersion" -> TestUtils.appInfo.version.asJson,
        "hashedHostnames"    -> hashedHostnames.asJson
      )
    )
  }

  "Telemetry" should {
    "send correct number of events with expected hostnames" in {
      val eventCount = 10
      val timeout    = (interval * eventCount.toLong) + 1.minutes
      val probe      = probeTelemetry(telemetryConfig)
      TestControl
        .execute(
          probe.telemetryStream.timeout(timeout).compile.drain.voidError
        )
        .flatMap { tc =>
          tc.tick >>
            (1 to eventCount)
              .map { i =>
                probe.hostnameSet.add(i.toString) >> tc.advanceAndTick(interval)
              }
              .toList
              .sequence_
        }
        .unsafeRunSync()
      val events   = probe.telemetryEvents
      val expected = (1 to eventCount).map(i => expectedEvent(telemetryConfig, i)).toList
      events must beEqualTo(expected)
    }

    "not send any events if telemetry is disabled" in {
      val probe = probeTelemetry(telemetryConfig.copy(disable = true))
      TestControl
        .executeEmbed(
          probe.telemetryStream.timeout(interval * 10).compile.drain.voidError
        )
        .unsafeRunSync()
      probe.telemetryEvents must beEmpty
    }
  }

  "HostnameSet" should {
    "return hashed versions of stored hostnames" in {
      val count       = 10
      val hostnameSet = Telemetry.HostnameSet.init[IO](telemetryConfig).unsafeRunSync()
      (1 to count).foreach(i => hostnameSet.add(s"hostname-$i").unsafeRunSync())
      val expected = (1 to count).map(i => DigestUtils.sha256Hex(s"hostname-$i")).toSet
      val result   = hostnameSet.getHashed.unsafeRunSync()
      result must beEqualTo(expected)
    }

    "not store any hostname if telemetry is disabled" in {
      val count       = 10
      val hostnameSet = Telemetry.HostnameSet.init[IO](telemetryConfig.copy(disable = true)).unsafeRunSync()
      (1 to count).foreach(i => hostnameSet.add(s"hostname-$i").unsafeRunSync())
      hostnameSet.getHashed.unsafeRunSync() must beEmpty
    }
  }
}
