package com.snowplowanalytics.snowplow.collector.core

import org.typelevel.log4cats.Logger
import org.typelevel.log4cats.slf4j.Slf4jLogger

import org.apache.commons.codec.digest.DigestUtils

import cats.data.NonEmptyList
import cats.implicits._

import cats.effect.{Async, Resource, Sync}
import cats.effect.std.Random
import cats.effect.kernel.Ref

import fs2.Stream

import org.http4s.client.{Client => HttpClient}

import _root_.io.circe.Json
import _root_.io.circe.syntax._

import com.snowplowanalytics.iglu.core.{SchemaKey, SchemaVer, SelfDescribingData}

import com.snowplowanalytics.snowplow.scalatracker.{Tracker, Tracking}
import com.snowplowanalytics.snowplow.scalatracker.Emitter._
import com.snowplowanalytics.snowplow.scalatracker.Emitter.{Result => TrackerResult}
import com.snowplowanalytics.snowplow.scalatracker.emitters.http4s.Http4sEmitter

object Telemetry {

  implicit private def unsafeLogger[F[_]: Sync]: Logger[F] =
    Slf4jLogger.getLogger[F]

  def run[F[_]: Async: Tracking](
    telemetryConfig: Config.Telemetry,
    httpClient: HttpClient[F],
    appInfo: AppInfo,
    appGeneratedId: String,
    region: Option[String],
    cloud: Option[String],
    hostnameSet: HostnameSet[F]
  ): Stream[F, Unit] =
    if (telemetryConfig.disable)
      Stream.empty.covary[F]
    else {
      Stream.resource(initTracker(telemetryConfig, appInfo.moduleName, httpClient)).flatMap { tracker =>
        Stream.fixedDelay[F](telemetryConfig.interval).evalMap { _ =>
          for {
            hostnames <- hostnameSet.getHashed
            sdj = makeHeartbeatEvent(
              telemetryConfig,
              region,
              cloud,
              appInfo.moduleName,
              appInfo.version,
              appGeneratedId,
              hostnames
            )
            _ <- tracker.trackSelfDescribingEvent(unstructEvent = sdj)
            _ <- tracker.flushEmitters()
          } yield ()
        }
      }
    }

  private def initTracker[F[_]: Async: Tracking](
    config: Config.Telemetry,
    appName: String,
    client: HttpClient[F]
  ): Resource[F, Tracker[F]] =
    for {
      random <- Resource.eval(Random.scalaUtilRandom[F])
      emitter <- {
        implicit val r: Random[F] = random
        Http4sEmitter.build(
          EndpointParams(config.url, port = Some(config.port), https = config.secure),
          client,
          retryPolicy = RetryPolicy.MaxAttempts(10),
          callback    = Some(emitterCallback[F] _)
        )
      }
    } yield new Tracker(NonEmptyList.of(emitter), "tracker-telemetry", appName)

  private def emitterCallback[F[_]: Sync](
    params: EndpointParams,
    req: Request,
    res: TrackerResult
  ): F[Unit] =
    res match {
      case TrackerResult.Success(_) =>
        Logger[F].debug(s"Telemetry heartbeat successfully sent to ${params.getGetUri}")
      case TrackerResult.Failure(code) =>
        Logger[F].warn(s"Sending telemetry hearbeat got unexpected HTTP code $code from ${params.getUri}")
      case TrackerResult.TrackerFailure(exception) =>
        Logger[F].warn(
          s"Telemetry hearbeat failed to reach ${params.getUri} with following exception $exception after ${req.attempt} attempts"
        )
      case TrackerResult.RetriesExceeded(failure) =>
        Logger[F].error(s"Stopped trying to send telemetry heartbeat after following failure: $failure")
    }

  private def makeHeartbeatEvent(
    teleCfg: Config.Telemetry,
    region: Option[String],
    cloud: Option[String],
    appName: String,
    appVersion: String,
    appGeneratedId: String,
    hashedHostnames: Set[String]
  ): SelfDescribingData[Json] =
    SelfDescribingData(
      SchemaKey("com.snowplowanalytics.oss", "oss_context", "jsonschema", SchemaVer.Full(1, 0, 2)),
      Json.obj(
        "userProvidedId"     -> teleCfg.userProvidedId.asJson,
        "autoGeneratedId"    -> teleCfg.autoGeneratedId.asJson,
        "moduleName"         -> teleCfg.moduleName.asJson,
        "moduleVersion"      -> teleCfg.moduleVersion.asJson,
        "instanceId"         -> teleCfg.instanceId.asJson,
        "appGeneratedId"     -> appGeneratedId.asJson,
        "cloud"              -> cloud.asJson,
        "region"             -> region.asJson,
        "applicationName"    -> appName.asJson,
        "applicationVersion" -> appVersion.asJson,
        "hashedHostnames"    -> hashedHostnames.asJson
      )
    )

  case class TelemetryInfo(
    region: Option[String],
    cloud: Option[String]
  )

  trait HostnameSet[F[_]] {
    def add(hostname: String): F[Unit]
    def getHashed: F[Set[String]]
  }

  object HostnameSet {
    private def create[F[_]: Sync]: F[HostnameSet[F]] =
      Ref
        .of[F, Set[String]](Set.empty)
        .map(ref =>
          new HostnameSet[F] {
            override def add(hostname: String): F[Unit] =
              ref.update(_ + hostname)

            override def getHashed: F[Set[String]] =
              ref.get.map(s => s.map(DigestUtils.sha256Hex))
          }
        )

    private def createNoop[F[_]: Sync]: F[HostnameSet[F]] =
      Sync[F].pure {
        new HostnameSet[F] {
          override def add(hostname: String): F[Unit] = Sync[F].unit
          override def getHashed: F[Set[String]]      = Sync[F].pure(Set.empty)
        }
      }

    def init[F[_]: Sync](telemetryConfig: Config.Telemetry): F[HostnameSet[F]] =
      if (telemetryConfig.disable) createNoop[F] else create[F]
  }
}
